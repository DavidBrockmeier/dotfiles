#!/bin/bash

verbose() {
    if [ -n "$verbose" ]; then
        echo "$*"
    fi
}

dangerous() {
    # -i and -s cannot be arguments to zoxide query
    if [ "$1" == "-i" ]; then
        verbose "sorry, can't check for -i"
        return 0
    fi
    if [ "$1" == "-s" ]; then
        verbose "sorry, can't check for -s"
        return 0
    fi
    local strippedWhitespace=$(echo $1 | xargs)
    if [ "$1" != "$strippedWhitespace" ]; then
        verbose "space is a bad abbreviation ($1)"
        return 0
    fi
    return 4
}

findAbbrevs() {
    local directory="$1"
    local basename=$(basename "$directory" | tr '[:upper:]' '[:lower:]')

    local baseLength=${#basename}
    for ((length = 1; length < baseLength + 1; length++)); do
        local abbrevs=()
        local endoffset=$([ -n "$start_only" ] && echo 1 || echo $((baseLength - length + 1)))
        for ((offset = 0; offset < $endoffset; offset++)); do
            local fragment="${basename:$offset:$length}"
            if dangerous "$fragment"; then
                continue
            fi
            local foundDirectory=$(zoxide query "$fragment" 2>/dev/null)
            if [[ $? -gt 0 || "$foundDirectory" == '' ]]; then
                continue
            fi
            local realFoundDirectory=$(realpath "$foundDirectory")

            if [[ "$realFoundDirectory" == "$directory" ]]; then
                abbrevs+=("$fragment")
            fi
        done
        if [ ${#abbrevs[@]} -gt 0 ]; then
            # only report unique abbrevs
            echo "${abbrevs[@]}" | tr ' ' '\n' | awk '!a[$0]++'
            exit 0
        fi
    done

    echo "No abbreviation found for $(basename $directory)" 1>&2
    exit 1
}

help() {
    echo 'Find the shortest abbreviations to autojump (a.k.a. "z") to the given (or current) directory'
    echo
    echo "USAGE:"
    echo "  $(basename $0) [<folder to find z abbrev for>]"
    echo
    echo "FLAGS:"
    echo "  -h  Print help"
    echo "  -v  Verbose output"
    echo "  -s  Include only abbreviations that start the same as the directory name"
}

while getopts "vsh" opt; do
    case $opt in
    v) verbose=1 ;;
    s) start_only=1 ;;
    h) help; exit 0 ;;
    *) echo; help; exit 2 ;;
    esac
done
shift $(($OPTIND - 1))

if [ -z "$*" ]; then
    directory=$(realpath "$PWD")
else
    directory=$(realpath "$*")
    if [ ! -d "$directory" ]; then
        echo "$directory is not a valid, existing directory" 1>&2
        exit 3
    fi
fi

findAbbrevs "$directory"
