#!/bin/bash

verbose() {
    if [ -n "$verbose" ]; then
        echo "$*"
    fi
}

dangerous() {
    local strippedWhitespace=$(echo $* | xargs)
    if [ "$*" != "$strippedWhitespace" ]; then
        verbose "space is a bad abbreviation ($*)"
        return 0
    fi
    # -i and -s cannot be arguments to zoxide query
    if [ "$*" == "-i" ]; then
        verbose "sorry, can't check for -i"
        return 0
    fi
    if [ "$*" == "-s" ]; then
        verbose "sorry, can't check for -s"
        return 0
    fi
    if [ "$*" == "~" ]; then
        verbose "tilde is a bad abbreviation"
        return 0
    fi
    if [[ "$*" =~ ^"~".* ]]; then
        verbose "starting with tilde is a bad abbreviation"
        return 0
    fi
    return 4
}

findAbbrevs() {
    local directory="$*"
    local basename=$(basename "$directory" | tr '[:upper:]' '[:lower:]')

    local baseLength=${#basename}
    for ((length = 1; length < baseLength + 1; length++)); do
        local abbrevs=()
        local endoffset=$([ -n "$start_only" ] && echo 1 || echo $((baseLength - length + 1)))
        for ((offset = 0; offset < $endoffset; offset++)); do
            local fragment="${basename:$offset:$length}"
            if dangerous "$fragment"; then
                continue
            fi
            local foundDirectory=$(zoxide query "$fragment" 2>/dev/null)
            if [[ $? -gt 0 || "$foundDirectory" == '' ]]; then
                continue
            fi
            local realFoundDirectory=$(realpath "$foundDirectory")

            if [[ "$realFoundDirectory" == "$directory" ]]; then
                abbrevs+=("$fragment")
            fi
        done
        if [ ${#abbrevs[@]} -gt 0 ]; then
            local abbrevs_found=true
            # only report unique abbrevs
            (
                IFS=$'\n'
                echo "${abbrevs[*]}"
            ) | awk '!a[$0]++'
            if [ -z "$all" ]; then
                exit 0
            fi
        fi
    done

    if [ "$abbrevs_found" == true ]; then
        exit 0
    fi

    echo "No abbreviation found for $(basename $directory)" 1>&2
    exit 1
}

help() {
    echo 'Find the shortest abbreviations that can be used to autojump (a.k.a. "z") to the given (or current) directory'
    echo
    echo "USAGE:"
    echo "  $(basename $0) [<folder to find z abbrev for>]"
    echo
    echo "FLAGS:"
    echo "  -s  Include only abbreviations that start the same way as the directory name"
    echo "  -a  Enumerate all possible abbreviations, even the ones that are not the shortest"
    echo "  -v  Verbose output"
    echo "  -h  Print help"
}

while getopts "vsah" opt; do
    case $opt in
    v) verbose=1 ;;
    s) start_only=1 ;;
    a) all=1 ;;
    h)
        help
        exit 0
        ;;
    *)
        echo
        help
        exit 2
        ;;
    esac
done
shift $(($OPTIND - 1))

if [ -z "$*" ]; then
    directory=$(realpath "$PWD")
else
    directory=$(realpath "$*")
    if [ ! -d "$directory" ]; then
        echo "$directory is not a valid, existing directory" 1>&2
        exit 3
    fi
fi

findAbbrevs "$directory"
