#!/bin/bash

verbose() {
    if [ -n "$verbose" ]; then
        echo "$*"
    fi
}

dangerous() {
    local strippedWhitespace
    strippedWhitespace=$(echo "$@" | xargs)
    if [ "$*" != "$strippedWhitespace" ]; then
        verbose "space is a bad abbreviation ($*)"
        return 0
    fi
    # -i and -s cannot be arguments to zoxide query
    if [ "$*" == "-i" ]; then
        verbose "sorry, can't check for -i"
        return 0
    fi
    if [ "$*" == "-s" ]; then
        verbose "sorry, can't check for -s"
        return 0
    fi
    if [ "$*" == "~" ]; then
        verbose "tilde is a bad abbreviation"
        return 0
    fi
    if [[ "$*" =~ ^"~".* ]]; then
        verbose "starting with tilde is a bad abbreviation"
        return 0
    fi
    return 4
}

findAbbrevs() {
    local directory
    directory="$*"

    local basename
    basename=$(basename "$directory" | tr '[:upper:]' '[:lower:]')

    local baseLength
    baseLength=${#basename}

    for ((length = 1; length < baseLength + 1; length++)); do
        local abbrevs
        abbrevs=()

        local endoffset
        endoffset=$([ -n "$shortest" ] || [ -n "$all" ] && echo $((baseLength - length + 1)) || echo 1)

        for ((offset = 0; offset < endoffset; offset++)); do
            local fragment
            fragment="${basename:$offset:$length}"
            if dangerous "$fragment"; then
                continue
            fi
            local foundDirectory
            if ! foundDirectory=$(zoxide query "$fragment" 2>/dev/null); then
                continue
            fi
            if [[ "$foundDirectory" == '' ]]; then
                continue
            fi
            local realFoundDirectory
            realFoundDirectory=$(realpath "$foundDirectory")

            if [[ "$realFoundDirectory" == "$directory" ]]; then
                abbrevs+=("$fragment")
            fi
        done
        if [ ${#abbrevs[@]} -gt 0 ]; then
            local abbrevs_found
            abbrevs_found=true
            # only report unique abbrevs
            (
                IFS=$'\n'
                echo "${abbrevs[*]}"
            ) | awk '!a[$0]++'

            if [ -z "$all" ]; then
                exit 0
            fi
        fi
    done

    if [ "$abbrevs_found" == true ]; then
        exit 0
    fi

    echo "No abbreviation found for $(basename "${directory}")" 1>&2
    exit 1
}

help() {
    echo 'Find the shortest abbreviations that can be used to autojump (a.k.a. "z") to the given (or current) directory'
    echo
    echo "By default, only abbreviations that start the same way as the directory name are returned."
    echo "Non-contiguous, i.e. space separated, abbreviations are not looked for. So, in some, fairly rare, circumstances the shortest abbreviations may not be found."
    usage
}

usage() {
    echo
    echo "USAGE:"
    echo "  $(basename "$0") [<folder to find z abbrevs for, defaults to current>]"
    echo
    echo "FLAGS:"
    echo "  -s  Allow abbreviations even if they do not start the same way as the directory name. (This will often find shorter abbreviations, but they may be less easy to remember)"
    echo "  -a  List all (contiguous) abbreviations (implies -s)"
    echo "  -v  Verbose output"
    echo "  -h  Print help"
}

while getopts "vsah" opt; do
    case $opt in
    v) verbose=1 ;;
    s) shortest=1 ;;
    a) all=1 ;;
    h)
        help
        exit 0
        ;;
    *)
        usage
        exit 2
        ;;
    esac
done
shift $((OPTIND - 1))

if [ -z "$*" ]; then
    directory=$(realpath "$PWD")
else
    directory=$(realpath "$*")
    if [ ! -d "$directory" ]; then
        echo "$directory is not a valid, existing directory" 1>&2
        exit 3
    fi
fi

findAbbrevs "$directory"
